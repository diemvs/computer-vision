## **Задания для семинара по работе с ONNX**

Ниже представлены пять практических заданий. Выполните их по порядку, чтобы закрепить навыки оптимизации моделей и конвертации в формат ONNX.

---

### **Задание 1. Экспорт модели PyTorch в ONNX с динамическими осями**

1. Создайте простую модель в PyTorch (достаточно небольшой полносвязной или свёрточной сети).  
2. Обучите её или инициализируйте случайными весами, если нет доступных данных.  
3. Экспортируйте модель в формат ONNX, указав динамическую ось хотя бы для размера батча.  
4. Сохраните модель в файл `model.onnx`.  
5. Проверьте корректность, загрузив её в ONNX Runtime и сравнив предсказания с предсказаниями PyTorch.

---

### **Задание 2. Квантование модели в ONNX Runtime**

1. Возьмите готовый `.onnx`-файл (можно использовать модель из Задания 1).  
2. Примените динамическое квантование весов (int8) с помощью утилит `onnxruntime.quantization`.  
3. Определите разницу в размере между исходным и квантованным `.onnx`-файлом.  
4. Оцените, насколько отличаются результаты предсказания на тестовых данных (или случайном входе) до и после квантования.

---

### **Задание 3. Оптимизация ONNX-модели с помощью ONNX Optimizer**

1. Возьмите `.onnx`-модель (исходную или квантованную).  
2. Установите `onnx` и воспользуйтесь модулем `onnx.optimizer`.  
3. Примените несколько проходов оптимизации (например, “eliminate_deadend”, “fuse_add_bias_into_conv” и “fuse_bn_into_conv”).  
4. Сохраните результат под новым именем и выполните модель через ONNX Runtime.  
5. Сравните, совпадает ли выход оптимизированной модели с исходной.

---

### **Задание 4. Создание веб-сервиса для инференса с ONNX Runtime**

1. Напишите минимальное Flask-приложение, загружающее ONNX-модель и обрабатывающее POST-запросы на предсказание.  
2. Запустите сервер и убедитесь, что отправляемые данные корректно обрабатываются моделью.  
3. На выходе возвращайте результаты инференса в JSON-формате.

---

### **Задание 5. Нагрузочное тестирование и сравнение квантованной и неквантованной моделей**

1. Имея две версии одной и той же модели (обычную и квантованную), поднимите два веб-сервиса на разных портах.  
2. Используйте `ab`, `locust` или аналогичные инструменты для нагрузки, отправив несколько сотен или тысяч запросов.  
3. Сравните время отклика (latency) и пропускную способность (RPS) для квантованной и неквантованной моделей.  
4. Сделайте вывод, насколько квантование ускорило инференс и как это отразилось на качестве (если у вас есть метрика точности).

---

